---
layout: base
title: Mida - A Microdata extractor/parser library for Ruby
menuOption: home
---

<h2>Mida</h2>
Mida is a Microdata extractor/parser library for Ruby.

<h2>Installation</h2>
Mida keeps RubyGems up-to-date with its latest version, so installing is as easy as:<br />

{% highlight bash %}
$ gem install mida
{% endhighlight %}

<h3>Requirements:</h3>
<ul>
  <li>Nokogiri</li>
</ul>

<h2>Command Line Usage</h2>

To use the command line tool, supply it with the urls or filenames that you would like to be parsed (by default each item is output as yaml):<br />
{% highlight bash %}
mida http://lawrencewoodman.github.com/mida/news/
{% endhighlight %}

If you want to search for specific types you can use the <code>-t</code> switch followed by a Regular Expression:
{% highlight bash %}
mida -t /person/i http://lawrencewoodman.github.com/mida/news/
{% endhighlight %}

For more information look at mida‘s help:
{% highlight bash %}
mida -h
{% endhighlight %}

<h2>Library Usage</h2>

The following examples assume that you have required <code>mida</code>
and <code>open-uri</code>.

<h3>Extracting Microdata from a page</h3>

All the Microdata is extracted from a page when a new
<code>Mida::Document</code> instance is created.<br />
<br />
To extract all the Microdata from a webpage:<br />

{% highlight ruby %}
url = 'http://example.com'
open(url) {|f| doc = Mida::Document.new(f, url)}
{% endhighlight %}

The top-level Items will be held in an array accessible via
<code>doc.items</code>.<br />
<br />
To simply list all the top-level Items that have been found:<br />

{% highlight ruby %}
puts doc.items
{% endhighlight %}

<h3>Searching</h3>

If you want to search for an Item that has a specific itemtype/vocabulary
 his can be done with the search method.<br />
<br />
To return all the Items that use one of Google’s Review vocabularies:<br />

{% highlight ruby %}
doc.search(%r{http://data-vocabulary\.org.*?review.*?}i)
{% endhighlight %}

<h3>Inspecting an Item</h3>
Each Item is a <code>Mida::Item</code> instance and has four main methods of
interest: <code>type</code>, <code>vocabulary</code>, <code>properties</code>
and <code>id</code>.<br />
<br />
To find out the itemtype of the Item:<br />
{% highlight ruby %}
puts doc.items.first.type
{% endhighlight %}

To find out the itemid of the Item:<br />

{% highlight ruby %}
puts doc.items.first.id
{% endhighlight %}

Properties are returned as a hash containing name/values pairs. The values will
be an array of either <code>String</code> or <code>Mida::Item</code> instances.<br />
<br />
To see the properties of the Item:<br />
{% highlight ruby %}
puts doc.items.first.properties
{% endhighlight %}

<h3>Working with Vocabularies</h3>
Mida allows you to define vocabularies, so that input data can be constrained
to match expected patterns. By default a generic vocabulary
(<code>Mida::GenericVocabulary</code>) is registered, which will match against
any itemtype with any number of properties.<br />
<br />
If you want to specify a vocabulary, you create a class derived from
<code>Mida::Vocabulary</code> and use <code>itemtype</code>,
<code>has_one</code>, <code>has_many</code> and <code>extract</code>
to describe the vocabulary.<br />
<br />
As an example the following describes a subset of Google’s Review vocabulary:<br />
{% highlight ruby %}
class Rating < Mida::Vocabulary
  itemtype %r{http://data-vocabulary.org/rating}i
  has_one 'best'
  has_one 'worst'
  has_one 'value'
end

class Review < Mida::Vocabulary
  itemtype %r{http://data-vocabulary.org/review}i
  has_one 'itemreviewed'
  has_one 'rating' do
    extract Rating, Mida::DataType::Text
  end
end
{% endhighlight %}

When you create a subclass of <code>Mida::Vocabulary</code> it automatically
registers the Vocabulary.<br />
<br />
Now if Mida is parsing some input and manages to match against the
<code>Review</code> <code>Vocabulary</code>, it will only allow the specified
properties and will reject any that don't have the correct number. It will
also set <code>Item#vocabulary</code> accordingly, e.g.

{% highlight ruby %}
doc.items.first.vocabulary      # => Review
{% endhighlight %}

If you want to include the properties of another vocabulary you can use <code>include_vocabulary</code>:
{% highlight ruby %}
class Thing < Mida::Vocabulary
  itemtype %r{http://example.com/vocab/thing}i
  has_one 'name', 'description'
end

class Book < Mida::Vocabulary
  itemtype %r{http://example.com/vocab/book}i
  include_vocabulary Thing
  has_one 'title', 'author'
end

class Collection < Mida::Vocabulary
  itemtype %r{http://example.com/vocab/collection}i
  has_many 'item' do
    extract Thing
  end
end
{% endhighlight %}

In the above if you gave a <code>Book</code> as an item of <code>Collection</code> this would be accepted
because it includes the <code>Thing</code> vocabulary. When examining the item you would
find <code>#vocabulary</code> set to <code>Book</code> and you would have access to all the properties of
<code>Thing</code> and all the properties of Book.
